diff --git a/node_modules/@apify/timeout/index.d.ts b/node_modules/@apify/timeout/index.d.ts
index 433e923..77fa205 100644
--- a/node_modules/@apify/timeout/index.d.ts
+++ b/node_modules/@apify/timeout/index.d.ts
@@ -1,13 +1,12 @@
 /// <reference types="node" />
 import { AsyncLocalStorage } from 'async_hooks';
 export interface AbortContext {
-    cancelTimeout: AbortController;
     cancelTask: AbortController;
 }
 /**
  * `AsyncLocalStorage` instance that is used for baring the AbortContext inside user provided handler.
  * We can use it to access the `AbortContext` instance via `storage.getStore()`, and there we can access
- * both `cancelTimeout` and `cancelTask` instances of `AbortController`.
+ * `cancelTask` instance of `AbortController`.
  */
 export declare const storage: AsyncLocalStorage<AbortContext>;
 /**
diff --git a/node_modules/@apify/timeout/index.js b/node_modules/@apify/timeout/index.js
index b8b3c94..8392dba 100644
--- a/node_modules/@apify/timeout/index.js
+++ b/node_modules/@apify/timeout/index.js
@@ -2,12 +2,11 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.addTimeoutToPromise = exports.tryCancel = exports.TimeoutError = exports.storage = void 0;
 // eslint-disable-next-line max-classes-per-file
-const promises_1 = require("timers/promises");
 const async_hooks_1 = require("async_hooks");
 /**
  * `AsyncLocalStorage` instance that is used for baring the AbortContext inside user provided handler.
  * We can use it to access the `AbortContext` instance via `storage.getStore()`, and there we can access
- * both `cancelTimeout` and `cancelTask` instances of `AbortController`.
+ * `cancelTask` instance of `AbortController`.
  */
 exports.storage = new async_hooks_1.AsyncLocalStorage();
 /**
@@ -64,7 +63,6 @@ async function addTimeoutToPromise(handler, timeoutMillis, errorMessage) {
     var _a;
     // respect existing context to support nesting
     const context = (_a = exports.storage.getStore()) !== null && _a !== void 0 ? _a : {
-        cancelTimeout: new AbortController(),
         cancelTask: new AbortController(),
     };
     let returnValue;
@@ -79,28 +77,19 @@ async function addTimeoutToPromise(handler, timeoutMillis, errorMessage) {
                 throw e;
             }
         }
-        finally {
-            context.cancelTimeout.abort();
-        }
     };
-    const timeout = async () => {
-        try {
-            await (0, promises_1.setTimeout)(timeoutMillis, undefined, { signal: context.cancelTimeout.signal });
+    return new Promise((resolve, reject) => {
+        const timeout = setTimeout(() => {
             context.cancelTask.abort();
-        }
-        catch (e) {
-            // ignore rejections (task finished and timeout promise has been cancelled)
-            return;
-        }
-        throw errorMessage instanceof Error
-            ? errorMessage
-            : new TimeoutError(errorMessage);
-    };
-    await new Promise((resolve, reject) => {
+            const error = errorMessage instanceof Error ? errorMessage : new TimeoutError(errorMessage);
+            reject(error);
+        }, timeoutMillis);
         exports.storage.run(context, () => {
-            Promise.race([timeout(), wrap()]).then(resolve, reject);
+            wrap()
+                .then(() => resolve(returnValue))
+                .catch(reject)
+                .finally(() => clearTimeout(timeout));
         });
     });
-    return returnValue;
 }
 exports.addTimeoutToPromise = addTimeoutToPromise;
